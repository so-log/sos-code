---
title: 'review - 03 This'
date: '2024-01-05'
lastmod: '2024-01-05'
tags: ['javascript', 'book', 'study']
draft: false
summary: '코어 자바스크립트를 읽고 This에 대해 더 알아보자.'
layout: PostLayout
canonicalUrl: https://sos-code.vercel.app/blog/book-this
---

: 다른 대부분의 객체 지향언어에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 하지만 자바스크립트에서의 this는 어디에서든 사용할 수 있기 때문에 상황에 따라 this의 대상이 달라진다.

# This

자바스크립트에서 this는 실행 컨텍스트가 생성될 때 함께 결정된다. > 함수를 호출할 때 결정된다.

## 상황에 따라 달라지는 this

1. 전역 공간에서의 this
   전역 객체, 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다. 브라우저 환경에서 전역객체는 window이고 nodw.js 환경에서는 global이다.

- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당한다. 변수이면서 객체의 프로퍼티이기도하다.
  p66 예제 2-2

```

var a = 1;
console.log(a);  // 1
console.log(window.a);  // 1
console.log(this.a);  // 1

```

window.a와 this.a 모두 1이 출력, 같은건 이해하지만 왜 1일까?

- 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작하기 때문
  사용자가 var 연산자를 이용해 변수를 선언했어도 자바스크립트엔진은 어떤 특정 객체의 프로퍼티로 인식한다.

특정 객체란 ? LexicalEnvironment(L.E)이다. 실행컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장한다.

따라서 var로 변수를 선언하는 대신 window의 프로퍼티에 집적 할당하더라도 같은 결과를 낼 수 있다.
p68 예제 3-4

```

var a = 1;
window.b = 2;
console.log(a, window.a, this.a); // 1 1 1
console.log(b, window.b, this.b); // 2 2 2

```

하지만 delete 연산자는 다르게 작동한다.

p68 예제3-5

```

var a = 1;
delete window.a;    // false
console.log(a, window.a, this.a);   /// 1 1 1

window.c = 3;
delete window.c; // true
console.log(c, window.c, this.c);  // Uncaught ReferenceError: c is not defined

```

2. 메서드로서 호출할 때 그 메서드 내부에서의 this

### 함수 vs 메서드

'어떤 함수를 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.'
함수로서의 호출과 메서드로서의 호출은 함수 앞의 점(.)으로 구분한다.
함수 앞에 점이 있으면? 메서드로서의 호출이다. (대괄호 표기법도 포함)

p71 예제 3-7

```
var obj = {
    method: function (x) { console.log(this, x); }
};

obj.method(1);   // { method: f } 1
obj['method'](2);   // { method: f } 2

```

즉, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 잇는 경우에는 메서드로 호출한 것이다.

### 메서드 내부에서의 this

메서드로서 호출하는 경우 호출 주체는 함수명(프로퍼티명)앞의 객체이다. 점 앞의 객체가 곧 this!
p71 예제 3-8

```

var obj = {
methodA: function () { console.log(this); },
    inner: {
        methodB: function () { console.log(this); }
    }
};

object.methodA();   // {methodA: f, inner: {...} } ( === obj )
object.inner.methodB();  // {methodB: F} ( === obj.inner)

```

3. 함수로서 호출할 때 그 함수 내부에서의 this

### 함수 내부에서의 this

어떤 함수를 함수로서 호출하는 경우에는 this가 지정되지 않는다. this에는 호출한 주체가 담기는데 함수로서 호출하는 것은 호출 주체의 정보를 알 수 없다.
지정되지 않는 this는 전역 객체를 바라본다. 따라서 함수에서의 this는 전역 객체를 가리킨다.

### 메서드의 내부함수에서의 this

내부함수에서의 this > 함수로서 호출했는지, 메서드로서 호출했는지 파악하는게 중요하다.

p72 예제 3-9

```

var obj1 = {
	outer: function() {
		console.log(this);   // (1)
		var innerFunc = function() {
			console.log(this);    // (2) 전역객체(window) (3)obj2
		}
		innerFunc(); // --- (2) (3)

		var obj2 = {
			innerMethod : innerFunc
		};
		object2.innerMethod();
	}
}
obj1.outer();

```

1. 객체를 생성, 객체 내부에는 outer 프로퍼티 - 익명함수가 연결, 생성된 객체를 변수 obj1에 할당
2. obj1.outer() 호출
3. obj1.outer 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보 수집하고, this 바인딩
   호출할때 outer 앞에 .이 있었으므로 메서드로서의 호출 > this 는 점 앞에 obj1
4. console.log(this) --- (1) : obj1 객체 정보가 출력
5. 호이스팅된 변수 **innerFunc**는 outer 스코프 내에서만 접근할 수 있는 지역변수, 이 지역변수에 익명 함수 할당
6. innerFunc() 호출
7. innerFunc 실행 컨텍스트가 생성되면서 호이스팅, 스코프 체인 수집, this 바인딩 수행
   이 함수를 호출할 때 함수명 앞에는 .이 없으므로 함수로서의 호출 > this 지정 X, 자동으로 전역객체(Window) 바인딩
8. console.log(this) --- (2) : Window 객체 정보가 출력
9. 호이스팅 된 변수 **obj2**도 outer 스코프 내에서만 접근할 수 있는 지역변수, 여기에는 객체를 할당
   이 객체에는 innerMethod라는 프로퍼티, 이 프로퍼티에 innerFunc와 연결된 익명 함수와 연결
10. obj2.innerMethod() 호출
11. obj2.innerMethod 실행 컨텍스트가 생성
    이 함수를 호출할때 앞에 .이 있으므로 메서드로서의 호출 > this는 점 앞에 obj2
12. console.log(this) --- (3) : obj2 객체 정보가 출력

실행 결과 (1): { outer: f }, (2): Window { parent: ... }, (3): { innerMethod: f}

같은 innerFunc함수임에도 바인딩되는 this의 대상이 서로 달라졌다. > 주변 환경은 중요하지 않고 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지가 중요하다.

### 메서드의 내부 함수에서의 this를 우회하는 방법

호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용하고 싶다. > 스코프 체인과 일관성을 지키고 싶다.

하지만 ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없다.
대신 우회하는 방법이 변수를 활용하는 것이다.

p75 예제 3-10

```

var obj1 = {
	outer: function() {
		console.log(this);   // (1) { outer: f }
		var innerFunc1 = function() {
			console.log(this);    // (2) Window { ... }
		}
		innerFunc1();

        var self = this;
		var innerFunc2 = function() {
			console.log(self);    // (3) { outer: f }
		}
		innerFunc2();
	}
}
obj1.outer();

```

> 상위 스코프의 this를 저장해서 내부함수에서 활용한다.

### this를 바인딩하지 않는 함수

ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했다.
화살표함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정을 생략해 상위 스코프의 this를 그대로 활용할 수 있다.

p76 예제 3-11

```

var obj = {
	outer: function() {
		console.log(this);    // (1) { outer: f}
		var innerFunc = () => {
			console.log(this);  // (2) { outer: f}
		};
		innerFunc();
	}
}
obj.outer();

```

4. 콜백 함수 호출 시 그함수 내부에서의 this

   콜백함수? 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다.

   - 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정, 특별히 정의하지 않은 경우에는 전역객체를 바인딩한다.

   ```
   p77 addEventListener...
   ```

5. 생성자 함수 내부에서의 this

   생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수이다.
   객체지향언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라고 한다.

   자바스크립트에서는 new 명령어와 함께 함수를 호출하면 함수가 생성자로 동작한다. 이 내부에서의 this는 인스턴스 자신이 된다.
   즉, new와 함께 함수 호출: 생성자 함수 호출 > 생성자의 prototype을 참조하는 **proto** 가 있는 객체(인스턴스)를 생성 > 미리 준비된 공통 속성을 객체(this)에 부여

## 명시적으로 this를 바인딩하는 방법

1. call

   ```
   Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])
   ```

   call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령이다. 이때 call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후 인자들을 호출할 함수의 매개변수로 한다.
   함수를 그냥 실행하면 this는 전역객체를 참조, call을 이용하면 임이의 객체를 this로 지정할 수 있다.

   p80 예제 3-14

   ```

   var func = function (a, b, c) {
       console.log(this, a, b, c);
   }

   func(1, 2, 3); // Window{ ... } 1 2 3
   func.call({ x: 1}, 4, 5, 6); // { x:1 } 4 5 6

   ```

   p80 예제 3-15

   ```

   var obj = {
       a: 1,
       method: function(x, y) {
           console.log(this.a, x, y)
       }
   }

   obj.method(2, 3); // 1 2 3
   obj.method.call({ a : 4 }, 5, 6) // 4 5 6

   ```

2. apply

   ```
   Function.prototype.apply(thisArg[, argsArray])
   ```

   apply 메서드는 call 메서드와 기능적으로 동일하지만, call은 첫 번째 인자를 제외한 나머지 모든 인자들을 매개변수로 지정하고
   apply는 두번째 인자를 배열로 받아 배열의 요소들을 매개변수로 지정한다.

   p81 예제 3-16

   ```

   var func = function (a, b, c){
       console.log(this, a, b, c);
   }

   func.apply({x: 1}, [4, 5, 6]); // {x : 1} 4 5 6

   var obj = {
       a: 1,
       method: function(x, y) {
           console.log(this.a, x, y);
       }
   };
   obj.method.apply({ a: 4 }, [5, 6]); //4 5 6

   ```

3. call / apply 메서드의 활용

   ### 유사배열객체에 배열 메서드를 적용

   객체에는 배열 메서드를 적용할 수 없다.
   하지만 유사배열객체의 경우 call 또는 apply메서드를 이용할 수 있다.
   **유사배열객체** ? key가 0 또는 양의 정수인 프로퍼티가 존재하고, length 프로퍼티 값이 0 또는 양의 정수인 객체

   p82 예제 3-17

   ```

   var obj = {
       0: 'a',
       1: 'b',
       2: 'c',
       length: 3
   };
   Array.prototype.push.call(obj, 'd');
   console.log(obj); // {0: 'a', 1: 'b', 2: 'c', 3: 'd', length: 4}

   var arr = Array.prototype.slice.call(obj);
   console.log(arr); // ['a', 'b', 'c', 'd']

   ```

   1. 배열 메서드인 push를 객체 obj에 적용 > 프로퍼티 3에 'd' 추가
   2. slice 메서드 적용해 객체를 배열로 전환 - call 로 객체의 얕은복사를 수행했으나 slice 가 배열메서드이므로 배열로 반환

   **slice**
   .slice(startIdx, lastIdx) > startIdx ~ lastIdx -1 까지 추출
   .slice() 매개변수가 아무것도 없을 때, 원본 배열의 얕은 복사본 반환

   - arguments객체, querySelectorAll, getElementsByClassName 등의 Node 선택자로 선택한 결과인 NodeList도 유사배열객체이다.
   - 배열처럼 index와 length 프로퍼티를 지니닌 문자열도 call/apply 메서드를 이용해 배열 메서드를 적용할 수 있다.

     단, 문자열은 length 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드 (push, pip, shift, unshift, splice 등)는 에러를 던지고,
     concat처럼 대상이 반드시 배열이어야하는 경우에는 제대로 된 결과를 얻을 수 없다.

   p84 예제 3-19

   ```

   const str = 'abc def';

   Array.prototype.push.call(str, ', pushed string');
   // Error: Cannot assign to read only property 'length' of object [object String]

   Array.prototype.concat.call(str, 'string'); // [String {"abc def"}, "string"]

   Array.prototype.every.call(str, function(char) {
   return char !== ' ';
   }); // false

   Array.prototype.some.call(str, function(char) {
   return char === ' ';
   }); // true

   const newArr = Array.prototype.map.call(str, function(char) {
   return char + '!';
   });

   console.log(newArr); // ['a!', 'b!', 'c!', ' !', 'd!', 'e!', 'f!']

   const newStr = Array.prototype.reduce.apply(str, [
   function(string, char, i) {
       return string + char + i;
   },
   '',
   ]);

   console.log(newStr); // "a0b1c2 3d4e5f6"

   ```

   call/apply를 사용해 형변환하는 것은 'this를 원하는 값으로 지정해서 호출한다'라는 의도와 다르다.
   slice 메서드는 오직 배열 형태로 복사하기위해 사용됐다.
   ES6에서는 유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 **Array.from** 메서드를 새로 도입했다.

   p84 예제 3-20

   ```

   const obj = {
   0: 'a',
   1: 'b',
   2: 'c',
   length: 3,
   };

   const arr = Array.from(obj);
   console.log(arr); // ['a', 'b', 'c']

   ```

   ### 생성자 내부에서 다른 생성자를 호출

   생성자 내부에서 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 간단하게 반복을줄일 수 있다.

   p85 예제 3-21

   ```

   function Person(name, gender) {
       this.name = name;
       this.gender = gender;
   }

   function Student(name, gender, job) {
       Person.call(this, name, gender); // Person과 중복되는 내용
       this.job = job;
   }

   function Employee(name, gender, hobby) {
       Person.apply(this, [name, gender]); // Person과 중복되는 내용
       this.hobby = hobby;
   }

   const so = new Student('so', 'female', '개발자');
   const hee = new Employee('hee', 'female', '영화감상');

   ```

   ### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply

   p86 예제 3-23

   ```

   const numbers = [10, 20, 3, 16, 45];
   // const max = Math.max.apply(null, numbers);
   // const min = Math.min.apply(null, numbers);

   // ES6 spread 연산자를 사용하면 더욱 간결하다.
   const max = Math.max(...numbers);
   const min = Math.min(...numbers)

   console.log(max, min); // 45 3

   ```

4. bind 메서드

```
Function.prototype.apply(thisArg[, arg1[, arg2[, ...]]])
```

bind는 call과 비슷하지만 즉시 호출하지 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드이다.

    bind의 목적
    1. this를 미리적용한다.
    2. 부분 적용 함수를 구현한다.

p87 예제 3-25

```

    const func = function(a, b, c, d) {
        console.log(this, a, b, c, d);
    };
    func(1, 2, 3, 4); // Window{ ... } 1 2 3 4

    // this 지정
    const bindFunc1 = func.bind({ x: 1 });

    bindFunc1(5, 6, 7, 8); // { x: 1 } 5 6 7 8

    // this 지정 + 부분 적용 함수 구현
    const bindFunc2 = func.bind({ x: 1 }, 4, 5);

    bindFunc2(6, 7); // { x: 1 } 4 5 6 7
    bindFunc2(8, 9); // { x: 1 } 4 5 8 9

```

    ### name 프로퍼티

    bind 메서드를 적용해서 새로 만든 함수는 name 프로퍼티에 'bound'가 붙는다.
    따라서 call이나 apply보다 코드를 추적하기 더 쉽다.

    ```

    console.log(func.name); // func
    console.log(bindFunc1.name); // bound func

    ```

    ### 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기

    앞에서 설명한 self등의 변수를 활용해 우회하는 방법 대신 call, apply, bind를 이용하면 더 깔끔하게 처리할 수 있다.

    p89 예제 3-27

    1. call

    ```

    var obj= {
        outer : function () {
            console.log(this);
            var innerFunc = function () {
                console.log(this);
            };

            // 호출시 call메서드 사용(this지정후 즉시 실행하므로)
            innerFunc.call(this);
        }
    };
    obj.outer();

    ```

    2. bind

     ```

    var obj= {
        outer : function () {
            console.log(this);

            // 함수 선언시 바로 bind메서드를 사용(return만 하므로)
            var innerFunc = function () {
                console.log(this);
            }.bind(this);

            innerFunc();
        }
    };
    obj.outer();

    ```

    3. callback함수에서의 bind

    ```

    var obj = {
    logThis: function () {
        console.log(this);
    },

    logThisLater1: function () {
        setTimeout(this.logThis, 500);
    },

    logThisLater2: function () {
        setTimeout(this.logThis.bind(this), 1000);
    },
    };

    obj.logThisLater1();
    obj.logThisLater2();

    ```

5. 화살표 함수의 예외사항

   앞에서 얘기했듯이 화살표 함수를 사용하면 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 생략된다.

6. 별도의 인자로 this를 받는 경우 (콜백 함수 내에서의 this)

   콜백 함수를 인자로 받는 메서드 중 일부는 thisArg를 지정하는 경우가 있다.
   이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내에서 this값을 원하는 대로 변경할 수 있다.

   이런 형태는 배열 메서드에 많이 있고 그래서 ES6에서 새로 등장한 Set, Map 등의 메서드에도 일부 존재한다.

   p92 예제 3-31

   ```

   Array.prototype.forEach(callback[, thisArg])
   Array.prototype.map(callback[, thisArg])
   Array.prototype.filter(callback[, thisArg])
   Array.prototype.some(callback[, thisArg])
   Array.prototype.every(callback[, thisArg])
   Array.prototype.find(callback[, thisArg])
   Array.prototype.findIndex(callback[, thisArg])
   Array.prototype.flatMap(callback[, thisArg])
   Array.prototype.from(arrayLike[, callback[, thisArg]])
   Set.prototype.forEach(callback[, thisArg])
   Map.prototype.forEach(callback[, thisArg])

   ```

   이 중 forEach의 예시를 보자.

   ```

   const report = {
       sum: 0,
       count: 0,
       add: function(){
           const args = Array.prototype.slice.call(arguments);
           args.forEach(function(entry){
           this.sum += entry;
           ++this.count;
       }, this);
      },
      average: function(){
        return this.sum / this.count;
      }
   };
   report.add(60, 85, 95);
   console.log(report.sum, report.count, report.average());    // 240 3 80

   ```

# 요약

- 전역공간에서의 this는 전역객체를 참조한다.
- 어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 객체를 참조한다.
- 함수로서 호출한 경우 this는 전역객체를 참조한다.
- 콜백 함수 내부에서 this는 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우 전역객체를 참조한다.
- 생성자 함수에서 this는 생성될 인스턴스를 참조한다.

* 명시적 binding이 있을때

- call, apply는 this를 명시적으로 지정하면서 호출한다.
- bind는 this및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 반환한다.
- 요소를 순회하면서 콜백함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 한다.
